SCHEMA
Kita harus bikin peraturan yg mengatur data-data yg
boleh dikirimkan USER. Kita gamau user ngirim sembarang
data ke API. Kita harus DEFINE DULU, 
data apa saja yg wajib dikirim dan boleh dikirim/data
apa saja yg akan diterima oleh API.
Schema = Contract
API = "I expect u to send a data like this, if u dont send it like this, ill give u an error"
Library Python PYDANTIC = untuk define SCHEMA yg kita inginkan



CRUD:
CREATE: use POST        path: /posts 
READ:   use GET         path: /posts/:id atau /posts
UPDATE: use PUT/PATCH   path: /posts/:id
DELETE: use DELETE      path: /posts/:id

url harus berupa plural (posts bukan post), ini adalah convention 
PUT:   pass all field/information even if its not change
PATCH: pass specific field that going to change

FastAPI punya builtin swagger UI yang bisa generate API docs secara otomatis
Tinggal ke url route, terus tambain /docs atau /redoc
contoh: http://127.0.0.1:8000/docs
atau pake: http://127.0.0.1:8000/redoc 

PACKAGE
Dalam python, suatu folder dinamakan package
tiap package harus punya __init__.py

DATABASE
DBMS (DATABASE MANAGEMENT SYSTEM) : penghubung antara kita dan database
Jadi, program kita tidak langsung berinteraksi dengan database, ada DBMS sebagai penengah

Program --> DBMS --> Database

Relational  : MySQL, PostgreSQL, oracle, sql server 
NoSQL       : MongoDB, DynamoDB, oracle, sql server

SQL = Bahasanya

Satu instance postgresql bisa menampung banyak database
Misalnya db1 untuk app1, db2 untuk app2, dsb.. dimana db db ini ditampung di satu instance 

Waktu kita pertama kali install db postgre, bakal ada database "postgres" di instance "postgres".
Saat kita ingin akses database dari instance postgres (making a connection to the database),
kita harus specify nama db nya.
Jadi, sistem postgres bakal ngebikin database "postgres" biar waktu pertama kali buat kita langsung
bisa ngakses database (default). Tapi kita ga bakal pake database "postgres" itu

Install PostgreSQL:
(1) pgAdmin => ini GUI nya
(2) stackBuilder -=> untuk install extra features 

Table in Relational db:
each column represent different attribute
each row represent different entry

Data type:
python      postgres
int, float  Int, decimal, precision
string      Varchar, text
boolean     boolean
list        array                   // tapi agak jarang

primary key: kolom yg khusus menyimpan unik ID dari tiap entry
tiap entry punya PRIMARY KEY yang berbeda

primary key juga bisa diisi email (ga harus id integer)

Intinya, tiap data/entry harus punya PRIMARY KEY sebagai pembeda dari entry data yg lain

Unique Constraint:
constraint yg ditambahkan saat kita ingin membuat attribute yang
harus UNIK untuk tiap entry tetapi bukan PRIMARY KEY

Not Null Constraint:
constraint yg ditambahkan saat kita ingin membuat attribute yang 
tidak boleh bernilai null (attribute harus memiliki nilai)

POSTGRESQL PG ADMIN
how to create a server: 
Klik kanan di Browser
Pilih Register > server
Ketik nama server
Ketik IP = "localhost" karena kita mau run di local, kalo kita run di cloud, masukin ip yg sesuai
masukin password

how to create a database instance:
klik kanan di database (yg ada di server)
isi nama database
save

Biasanya, kita hanya fokus ke satu hal: Schema
how to create a table:
ke database tadi yg udah kita bikin > schema > tables > klik kanan terus create > table
ketik namanya
masuk ke bagian column, tambahin attribute apa aja
Untuk tipe data bisa refer kesini:
https://www.postgresql.org/docs/current/datatype.html 
NOTE: data type serial adalah data type khusus yg nyimpen unique ID (dihandle otomatis sama postgre)
      unique id berupa counter auto increment by 1 (product pertama dapet serial 1, kedua dapet 2, 3, 4, 5, ...)
Misal kita bikin table "products"   
name        Data type                   Length          Scale       Not Null    primary Key?
name        character varying                                       YES         NO
price       integer                                                 YES         NO
id          serial                                                  NO          YES

cara delete table: Klik kanan dari table yg mau didelete (misal products) lalu pilih delete/drop

cara view entry/data
klik kanan products (salah satu table yg udah dibuat) lalu pilih view/edit data
Untuk data perusahaan yg biasanya milyaran, jangan coba2 view all rows, mending view first 100 rows atau last 100 rows

Nantinya, akan ditampilin underylying sql (sql operation yg menampilkan data yg diinginkan)
Di bagian bawahnya, ada entry2 dari database. Bisa kita modif/tambain, tapi jangan lupa kalo mau disave klik 
tombol SAVE DATA CHANGES (F6)

Jadi sebenarnya yg kita lakuin adalah "propose changes", bukan automatically save changes
Perhatikan data yg kita tambain dan blm disave akan dibold

cara edit schema:
klik tables yg mau diedit (misal products) 
klik kanan lalu pilih properties > column
Kita bisa add column, atau edit column tersebut (mau ditambain constraint kah, dsb dsb)

Jika sudah ada data pada database, dan akan ditambahkan attribute/column baru, maka
tiap data akan otomatis menambahkan attribute tersebut dengan catatan:
Jika attribute membolehkan NULL, maka value attribute pada tiap entry menjadi null
jika attribute tersebut menyediakan default, maka value attribute pada tiap entery menjadi default
jika attribute tidak membolehkan NULL dan tidak ada default, maka terjadi ERROR. Solusi: ya tambain default


Best Practice: Tambahkan attribute created_at berupa
timestamp untuk menyimpan waktu kapan entry ini dibuat?
Agar attribute ini otomatis terisi pada pembuatan entry baru, masukakn nilai default padaattribute = NOW()


Cara melakukan QUERY:
Klik kanan pada DATABASE INSTANCE (bukan pada tables atau server) > klik query tool

SQL COMMANDS: 
* terdapat dua macam kata pada sql commands, yaitu SQL SPECIFIC KEYWORDS dan user provided information
* capitalization pada SQL SPECIFIC optional, command2 dibawah ini tetep work kalo kita ngetik "select" atau "from" nya gapake kapital
* tapi, sesuai convention,lebih baik untuk mengcapitalize kata2 pada SQL SPECIFIC COMMAND

================================== VIEW ENTRY ==================================
SELECT <namaColumn> FROM <namaTables>; 
SELECT * FROM products;                   // select semua column dari table products

SELECT id AS productID FROM products;     // select column id lalu RENAME judul column menjadi productID
SELECT name AS nama_product, price AS harga_product, id AS id_product FROM products;

* cara melakukan filter: gunakan WHERE
SELECT * FROM products WHERE id = 8;
SELECT * FROM products WHERE name = 'TV';       // untuk attrivute yg menymipan tipe teks, jangan lupa tambahkan petik satu ''
SELECT * FROM products WHERE inventory != 0;
SELECT * FROM products WHERE inventory <> 0;    // sama aja dengan != 0

* filter dua atau lebih condition
SELECT * FROM products WHERE inventory > 0 AND price > 20000;
SELECT * FROM products WHERE price < 100000 OR price >= 1000000;

* IN (a,b,c,d) => ambil semua entry yg nilai attributenya memenuhi salah satu dari nilai tersebut 
SELECT * FROM products WHERE id IN (1,2,3,4,5); 

* LIKE <regex> => ambil semua entry yg nilai attributenya mmenuhi regex (% untuk menggantikan *)
SELECT * FROM products WHERE name LIKE 'TV%';        // TV BLUE, TV RED, TV YELLOW semua masuk
SELECT * FROM products WHERE name NOT LIKE 'TV%';   // semua kecuali tiga di atas
SELECT * FROM products WHERE name LIKE '%mo%';      // semua data yang mengandung mo entah di kanan, kiri, atau tengah 


* ORDER => untuk SORTING hasil query kita 
SELECT * FROM products ORDER BY price;          // defaultnya ascending
SELECT * FROM products ORDER BY price ASC;      // ascending
SELECT * FROM products ORDER BY price DESC;     // DESCending

* specify tiebreaker (untuk dua entry yg nilai parameter sortingnya sama sehingga tie)
SELECT * FROM products ORDER BY inventory DESC, price;      // jika jjumlah inventory sama, urutkan bds price (default ASC)

* LIMIT N => untuk set banyak entry maksimal yg mau ditampilin = N (untuk data ygm iliaran sgt berguna)
SELECT * FROM products WHERE price > 100000 ORDER BY price DESC LIMIT 5;

* OFFSET N => untuk skip sebanyak N elemen [berguna untuk PAGINATION pada API]
SELECT * FROM products WHERE price > 100000 ORDER BY price DESC LIMIT 1 OFFSET 5;

================================== ADD ENTRY ==================================
INSERT INTO <namaTable> (namaColumn) VALUES (value valuenya)
INSERT INTO products (name, price, inventory) VALUES ('Baju', 100000, 100);

* kalo responnya: INSERT 0 1 , maka artinya insert berhasil memasukkan 1 row 

INSERT INTO products (price, name, inventory) VALUES (100000, 'Baju', 100); // bisa juga ordernya ga sesuai order kolom di schema (tapi harus disesuaikan dengan order sebeluem VALUES)

* kalo mau ngereturn apa yg baru dibikin bisa pake RETURNING
// ini
INSERT INTO products (price, name, inventory) VALUES (300000000, 'car', 400);
SELECT * FROM products WHERE name = 'car';
//bisa diconvert jadi ini (* artinya return semua COLUMN//attribute)
INSERT INTO products (price, name, inventory) VALUES (300000000, 'car', 400) RETURNING *;

* bisa specify attribute mana aja yg mau ditampilin pake RETURNING
INSERT INTO products (price, name, inventory) VALUES (300000000, 'car', 400) RETURNING name, id;      // return field name/id aja 

* Bisa juga ngebuat lebih dari 1 entry secara bersamaan
INSERT INTO products (price, name, inventory) VALUES (700000000, 'limosin', 400), (5000, 'tisu', 100), (12000, 'pasta gigi', 199) RETURNING *;

================================== DELETE ENTRY ==================================
DELETE FROM <tableName> WHERE <condition>

DELETE FROM products WHERE id = 26;
SELECT * FROM products;
// bisa juga pake returning
DELETE FROM products WHERE id = 28 RETURNING *;

* Delete based of criteria
DELETE FROM products WHERE inventory = 0;

================================== UPDATE ENTRY ==================================
UPDATE <tableName> SET <updates1, updates2, ...> WHERE <conditions>

UPDATE products SET name = 'Hape Murah', price = 20 WHERE id = 22 ;

* bisa juga pake returning (ngereturn entry yg terupdate)
UPDATE products SET name = 'Hape Muahal', price = 20000000 WHERE id = 22 RETURNING *;

* update multiple rows
UPDATE products SET is_sale = true WHERE id > -1 RETURNING *;




POSTGRESQL DRIVER ON PYTHON: USING PSYCOPG LIBRARY
https://www.psycopg.org/docs/

* cursor digunakan untuk melakukan operasi sql dari python (cursor.execute(<sql command>))


>>> ORM (OBJECT RELATIONAL MAPPER)
ORM adalah layer of abstraction that sits between database and the program
Jadi, kita bisa melakukan operasi sql dari kode python, tanpa harus pake CLI sql

Traditional:  FASTAPI <---SQL---> DATABASE
VS 
ORM         : FASTAPI <--Python---> ORM <---psycopg+SQL---> DATABASE

Dengan ORM, kita bisa define table menjadi suatu MODEL di python
contoh:
class Post(Base):
      __tablename__ = "posts"
      id = Column(Integer, primary_key=True, index=True)         # Jadi model python ini benar-benar merepresentasikan column di database
      title = Column(String, index=True, nullable=False)

ONE OF THE MOST POPULAR PYTHON ORMS: SQLALCHEMY [its a standalone library, doesnt have any relationship with fastapi lib]
https://docs.sqlalchemy.org/en/20/
https://fastapi.tiangolo.com/tutorial/sql-databases/

SQLALCHEMY CUMA SEBAGAI ORM, HE CANT TALK TO THE DATABASE
jadi walaupun kita punya sqlalchemy, kita tetap butuh library psycopg2 untuk bisa
membuat connection dengan db postgre kita. sqlalchemy ini fungsinya cuma biar kita ga susah2 ngequery
pake raw sql, mempermudah query dengan menggunakan bahasa python 

> Jadi kita harus bikin python file baru namanya \
      - database.py untuk handle database connection 
      - models.py untuk membuat models (model disini layaknya table di database)
(jadi kita ga perlu bikin table/schema manual dari postgresql lagi, tapi kita bakal bikin secara otomatis pake sqlalchemy)
Di database.py, bikin model Base = declarative.base()
Di database.py tambain juga fungsi yg bisa membuat session untuk connect ke database
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

Di models.py, bikin model yg mengextend Base itu tadi
Di main.py tambain models.Base.metadata.create_all(bind=engine)


Lalu jangan lupa, di setiap path operation, tambain ke dalam parameter fungsinya
db: Session = Depends(get_db) 
yang berfungsi agar fungsi bisa membuat session dan connect ke database


Sqlalchemy tidak dibuat untuk menghandle migration (changing the column and schema of the database)
untuk handle migration pake library:
ALEMBIC

Beda PYDANTIC MODEL sama SQLALCHEMY MODEL APAAN SIH?
PYDANTIC MODEL atau biasa disebut SCHEMA MODEL
itu cuma berfungsi untuk mendefinisikan struktur dari request & response
dalam API, untuk memastikan apabila terjadi request, user HARUS menyediakan
field field yg ada dalam PYDANTIC MODEL
SQLALCHEMY MODEL berfungsi untuk mendefinisikan TABLES dalam untuk nantinya
dibikin di database postgresql. SQLALCHEMY MODEL juga berfungsi untuk melakukan query
seperti create, delete, update, filter, dsb dsb
Kesimpulannya, kita sebenernya ga butuh pydantic, tapi dengan pydantic kita ingin melakukan 
validasi dan pengetatan aturan mengenai apa saja filed yg harus dikirim di request
agar tidak terjadi error yg tidak diinginkan

Unutk Response, bestpracticenya juga menggunakan pydantic. Jangan return keseluruhan entry 
karena bisa jadi ada id, password, dan juga informasi2 sensitif yg gaperlu dikirim

Cara ngatur model pydantic untuk response: di dalam decorator, tambahkan parameter
 response_model=schemas.<schemResponse>

gimana jika response berupa list of pydantic model itu?
from typing import list
 response_model=List[schemas.<schemResponse>]

# NAMBAHIN FOREIGN KEY di pgADMIN
# Saat nambahin column, tambahkan juga CONSTRAINT (constraint > foreign key > add)
# misalkan mau menyambungkan table posts -> user (satu table post dimiliki satu entry user)
# jadi di table posts kita bikin column namanya user_id, lalu di constraint kita set posts_users_fkey (dari template <columnAwal>_<columnAkhir>_fkey)
# Lalu local column (user_id) References (users (table yg jadi reference)) dan referencing (id, user id di table users dinamainnya apa) 
# Lalu ke bagian Action untuk menentukan apa yang terjadi jika USER yg memiliki id tersebut di delete/di update
# CASCADE: jika user di delete, maka semua posts dengan id user tersebut juga akan didelete
# SET DEFAULT: jika user di delete, maka semua posts dengan id user tersebut akan di set id nya menjadi value DEFAULT

Tapi harusnya ini di set di sqlalchemy (ini cuma cara ngelakuin manual aja dari pgadmin langsung)

