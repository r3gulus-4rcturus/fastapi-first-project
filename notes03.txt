QUERY PARAMETER
contoh: https://www.traveloka.com/id-id/bus-and-shuttle/search?st=a107074.a103570&stt=CITY_GEO.CITY_GEO&stn=Kebumen.Surabaya&dt=23-06-2025
maka query parameternya:search?st=a107074.a103570&stt=CITY_GEO.CITY_GEO&stn=Kebumen.Surabaya&dt=23-06-2025
Parameternya:
 st=a107074.a103570
 stt=CITY_GEO.CITY_GEO
 stn=kebumen.Surabaya 
 dt=23-06-2025
 ...

jadi cara masukin query parameter:
pergi ke router/url dimana kalian mau hit endpoint

misalnya /posts dan mau tambain query parameter 'limit'=10
/posts?limit=10

cara implement di path operation: tambain sebagai argumen di function path operationnya 

Kita gaboleh nge hardcode informasi-informasi sensitif seperti secret key
buat jwt, API key, juga informasi url database yg jelas beda untuk deevlopment dan production
Jadi kita butuh tempat buat nyimpen url dan key segala macem, tapi bukan di CODEBASE kita
dimana? di ENVIRONMENT VARIABLE
Semua aplikasi yg ada di environment tersebut PASTI bisa mengakses environment VARIABLE

*NOTE = Environment Variable pasti bertipe STRING
        By convention nama env variable harus pake CAPSLOCK dan _

cara bikin environment variable = 
windows > edit system environment variables > 
Advance > Environment variables

Nanti ada dua bagian: User Variable (variabel yg hanya bisa diakses user windows skrg) 
                      System Variable (variabel sistem, bisa diakses semua user)

Lalu pergi ke User variable > New 
isi variable name dan value

Kalo mau akses di cmd, tutup dulu cmd nya lalu buka ulang
Kalo mau akses di terminal vs code, close dulu vs code nya, lalu buka ulang


kalo mau akses env variable di cmd
> echo %Path% // misalkan env variable yg mau diakses namanya path             

kalo mau akses env variable di python
import os
path = os.getenv("Path")

dalam development environment, akan ada 30 atau lebih environment variable
dan kalo kita nyettingnya manual satu satu kaya di atas, itu akan (1) memakan waktu lama (2) susah untuk di troubleshoot
ada cara otomatisnya: ENVIRONMENT FILE
jadi kita simpen semua environment file di .env file

*NOTE: ini hanya untuk DEVELOPMENT, bukan PRODUCTION
*NOTE: JANGAN PERNAH MASUKKAN .env FILE ke GIT [cara untuk memastikannya adalah dengan membuat file .gitignore, lalu isikan .env di dalamnya]

Isu yg terjadi juga terkadang kita lupa untuk melakukan validasi antara environment variabel di development dan production
Solusinya adalah: menggunakan PYDANTIC


FITUR LIKE/VOTES pada app kita
> users harus bisa like post
> hanya bisa like satu kali
> post harus bisa ngefetch data berapa total likenya

solusi: model Vote
punya dua column: post_id (foreign key dari post) dan user_id (foreign key dari user)
jadi satu entry = satu like, dimana user_id ngelike post_id
user_id itu boleh berulang, post_id boleh berulang
tapiii pasangan entry [user_id, post_id] gaboleh berulang.
Jadi, kita menggunakan konsep COMPOSITE KEY.
Mirip dengan PRIMARY KEY (satu colomn yg harus unique untuk tiap entry)
COMPOSITE KEY ini merupakan PRIMARY KEY yang cover banyak kolom.
Jadi bukan satu kolom saja yg unik, tapi dua kolom 

Nambah table di pgAdmin nya gimana?
tambahaja kaya biasa, dengan dua column (postid dan userid) sama-sama primary_key

ADVANCE POSTGRESQL. 
Gimana caranya melakukan fetching data yg perlu banyak informasi tapi cukup sekali query aja? 
solusi: joins.

https://neon.com/postgresql/postgresql-tutorial/postgresql-joins

ada banyak macem, INNER JOIN, OUTER JOIN, RIGHT JOIN, LEFT JOIN

nah kita mau ngefetch data user dari tiap post (kan tiap post punya owner_id, nah kita mau fetch user dengan owner_id tersebut)
Jadi kita mau nampilin data posts yg masing2 post dilengkapi data user

SELECT * FROM posts LEFT JOIN users ON posts.owner_id = users.id;

misalkan cuma mau ambil data title, content, sama email
SELECT title, content, email FROM posts LEFT JOIN users ON posts.owner_id = users.id;

hati2 kalo mau ambil id, karena table posts dan table users sama sama punya column id
SELECT posts.id, title, content, email FROM posts LEFT JOIN users ON posts.owner_id = users.id;


Gimana kalo mau ambil semua data dari table posts, tapi cuma data email dari table user?
SELECT posts.*, email FROM posts LEFT JOIN users ON posts.owner_id = users.id;

Menghitung ada berapa banyak POST yg dimiliki oleh suatu USER?
SELECT users.id, COUNT(*) FROM posts INNER JOIN users ON posts.owner_id = users.id GROUP BY users.id;
// Jadi, ada fungsi bawaan sql namanya COUNT(*) dimana kita bisa melakukan GROUP BY users.id (sehingga
// entry akan digroupkan berdasarkan users.id yang sama, lalu akan dihitung/count ada berapa entry posts
// yang dimiliki oleh user tersebut. Jadi kita dapet datanya deh user itu punya berapa post)

Menghitung ada berapa banyak POST yg dimiliki oleh suatu USER dan jika user tersebut ga ngepost maka kita itung jugak?
SELECT users.id, COUNT(*) FROM posts RIGHT JOIN users ON posts.owner_id = users.id GROUP BY users.id; 
// pake RIGHT JOIN, jadi walau ga ada post yg match dg dia, tetap diitung NULL
// masalahnya kalo kita COUNT(*), berarti kita ngecount semua data yg ada, termasuk satu data null. 
// Jadi hasil query kita nanti user-user yg ga punya postingan berarti kan data di table postsnya null.
// Nah itu akan dihitung sebagai satu entry sama di COUNT(*), makanya bernilai 1 di hasil entry nya

Solusinya: Count berdasarkan suatu kolom (jadi yg dicount apanya? posts.id nya. user itu punya berapa posts.id)
SELECT users.id, COUNT(posts.id) FROM posts RIGHT JOIN users ON posts.owner_id = users.id GROUP BY users.id;

Menghitung ada berapa banyak vote yg dimiliki oleh suatu post
SELECT posts.id, COUNT(user_id) FROM posts LEFT JOIN votes ON posts.id = votes.post_id GROUP BY posts.id;

Sekarang, kita fetch semua data posts lalu tambahkan berapa banyak votes nya
SELECT posts.*, COUNT(user_id) as votes FROM posts LEFT JOIN votes ON posts.id = votes.post_id GROUP BY posts.id;

kekurangan SQL ALCHEMY = saat kita menambahkan column di salah satu model di models.py
database tidak akan serta merta menerima update kita. Di sinilah kita memerlukan ALEMBIC

ALEMBIC = DATABASE MIGRATION TOOL
database migration tool allow us to incrementally track
changes to database schema and rollback changes to any point in time
https://alembic.sqlalchemy.org/en/latest/tutorial.html
https://alembic.sqlalchemy.org/en/latest/api/ddl.html

Pertama kita inisialisasi alembic
> alembic init alembic // bikin folder alembic baru namanya alembic
> lalu pergi ke file env.py di alembic, ambil instance Base dari app.models
 (from app.models import Base)
> lalu ubah target_metadata = Base.metadata
// kenapa ambil Base dari models.py bukan database.py? 
// karena kita ingin alembic membaca semua model table yg telah kita bikin di models.py
// kalo dia aksesnya cuma database.py, alembic gaakan bisa membaca model2 sqlalchemy yg kita bikin 

> selanjutnya ke Alembic.ini, ubah value dari sqlalchemy.url = driver://user:pass@localhost/dbname
> karena kita udah nulis di env variable, tinggal di rangkai aja
driver : driver dari postgresql disini adalah psycopg2
postgresql+psycopg2://postgres:bismillahmenanghackathon@localhost:5432/fastapi

tips: sekali lagi, bad practice kalo kita hardcoded
jadi solusinya, pergi ke env.py file, lalu di bawah config = config.context
tulis ini
form app.config import settings
config.set_main_option("sqlalchemy.url", f"postgresql+psycopg2://{settings.database_username}:{settings.database_password}@{settings.database_hostname}:{settings.database_port}/{settings.database_name}")
// set_main_option berfungsi untuk melakukan overwrite terhadap apapun data yg ada di alembic.ini
// nah karena kita mau ngehardcode sqlalchemy.url, jadi kita tlis tuh di argumen pertama, lalu argumen kedua adalah nilai yg bukan hardcodednya

alembic revision (untuk melakukan MIGRATIONS pada schema database)
> alembic revision -m "messagenya diisi disini"

kalo kita melakukan revision, nanti pasti ada satu file baru yg ditambahkan di folder 
alembic > versions

nah di dalam file .py itu terdapat dua fungsi utama yaitu upgrade() dan downgrade()
jadi kita harus naruh logic buat bikin table2 barunya di fungsi upgrade
nah logic buat delete table2 barunya di DOWNGRADE

contoh kita bikin 2 column pertama pada tables
upgrade.py
op.create_table(
        'posts',
        sa.Column('id', sa.Integer(), nullable=False, primary_key=True),
        sa.Column('title', sa.String(), nullable=False),
    )

downgrade.py:
op.drop_table('posts')

untuk melakukan upgrade:
> alembic upgrade <revisionNumber>

kalo mau cek alembic latest (udah diupgrade di revision keberapa)
> alembic current

kalo mau liat heads saat ini (migration terakhir yg telah dibuat)
beda sama current, kalo current, migration terakhir yang telah diinvoke UPGRADEnya
kalo head, itu migration terakhir yg baru dibuat pake (alembic revision), tapi blm 
pernah dieksekusi/dimigrate fungsi UPGRADEnya
> alembic heads

(alembic latest => alembic current (terakhir upgrade))
(alembic heads (terakhir bikin revision baru))

Cara gampang upgrade tanpa pake revision Number:
> alembic upgrade heads (kalo upgrade yg kita mau ada di revision heads/revision terakhir yg dibikin)

Gimana cara kita undo? misalkan kita gamau pake column2 yg ada di suatu revision
> alembic downgrade <revisionNumber>
atau
> alembic downgrade <jarakRevisionYgMauDiDowngradeDenganHead>

Imagine you have 5 migration revisions:
revision1 → revision2 → revision3 → revision4 → revision5
If you're currently at revision5 and you run:
alembic downgrade revision3
👉 What happens?
✅ Alembic rolls back:

revision5 (undo)
revision4 (undo)
✅ And leaves you at:
✅ revision3 (applied)
❌ revision4 (unapplied)
❌ revision5 (unapplied)
🟢 revision3 is still applied. It is NOT deleted or canceled.

untuk liat historynya:
> alembic history

Salah satu fitur yang akan sangat membantu: AUTOGENERATE FEATURES
biarkan alembic menentukan table/column apa yang "missing" dari schema database di postgresql dengan schema yang di models.py
> alembic revision --autogenerate -m "messagenya"
ini akan membuat revision otomatis, jadi yg tinggal kamu lakuin adalah memeriksa apakah data yg diubah pada revision benar,
jika ada yg salah tinggal diperbaiki, lalu jika udh bener semua tinggal alembic upgrade head kaya biasanya



CORS
kalo kita coba panggil API dari postman, bakal aman aman aja
tapi kenapa kalo kita manggilnya dari google.com (pergi ke inspect element terus ke console)
saat kita lakuin instruksi ini (manggil api pake js)
fetch('http://127.0.0.1:8000/').then(res => res.json()).then(console.log)
hasilnya malah error, messagenya 
Refused to connect to 'http://127.0.0.1:54406/' because it violates the following Content Security Policy directive: "connect-src chrome://resources chrome://theme 'self'"
melanggar CORS policy? what?

CORS (Cross Origin Resource Sharing) allows us to make a requests from a web browser on one domain
to a server on a different domain.
By default, API kita hanya meng allow web broser yang running di domain yang sama dengan domain server kita

Jadi, karena server kita running di localhost (127.0.0.1) dan kita melakukan request dari domain google.com,
maka google.com TIDAK BOLEH ngirim request ke server kita, karena domainnya berbeda (BY DEFAULT), 
diblock sama CORS ini.

Jadi, gimana caranya kita nge unblock CORS ini? kita bikin whitelist yaitu list dimana 
yaitu list domain mana aja yg bisa request API ke kita. settingnya di main.py

GITHUB
> jangan lupa tulis file-file yg sensitif dan gaperlu kita push ke GITHUB
> tulis di .gitignore

lalu untuk dependency, list semua dependency yg dibutuhkan untuk menjalankan 
app mu lalu (pipe) masukkan ke dalam satu file requirements.txt
> pip freeze > requirements.txt

lalu gimana cara orang lain menginstall semua dependency yg ada di requirements.txt? 
> pip install -r requirements.txt



